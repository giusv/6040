(in-package :6040)

(defmacro delay (expr)
     `(lambda () ,expr))

(defun force (delayed-object)
  (funcall delayed-object))

(defun add (to from val)
  (let ((size (array-dimension to 0)))
    (dotimes (i size)
      (setf (aref to i) (+ (aref from i) val)))))

(defun price ()
  (lambda (x)
    x))

(declaim (inline ema))
(defun ema (alpha)
  (declare (type double-float alpha))
  (declare (optimize (speed 3)
                     (safety 0)
                     (debug 0)))
  (let* ((1-alpha (- 1d0 alpha))
         (state 0d0))
    (declare (type double-float 1-alpha state))
    (lambda (x)
      (declare (type double-float x))
      (setf state (+ (* alpha x) (* 1-alpha state)))
      (format t " ema=~a " state)
      state)))

(defun bullish ()
  (lambda (x)
    (declare (ignore x))
    1))
(defun bearish () 
  (lambda (x)
    (declare (ignore x))
    -1))
(defun neutral () 
  (lambda (x)
    (declare (ignore x))
    0))


(defun wait-as (before event after)
  (pandoriclet ((state 0))
    (lambda (x) 
      (format t " state: ~a" state)
      (if (= state 0)
          (if (funcall event x)
              (progn (format t " *************")
                     (setf state 1) 
                     (funcall before x))
              (funcall before x)) 
          (progn 
            (format t " calling after")
            (funcall (force after) x))))))
;; (defun wait-as (before event after)
;;   (pandoriclet ((state 0))
;;     (if event
;;         (pandoric-hotpatch before after)))
;;   )


(defun cross-from-below (s1 s2)
  (lambda (x)
    (if (> (funcall s1 x) (funcall s2 x))
        (progn (format t " cross-from-below")
               t)
        nil)))

(defun cross-from-above (s1 s2)
  (lambda (x)
    (if (< (funcall s1 x) (funcall s2 x))
        (progn (format t " cross-from-above")
               t)
        nil)))

;; (defun cross-from-below (s1 s2)
;;   (let ((state 0))
;;     (lambda (x)
;;       (if (= state 0)
;;           (if (> (funcall s1 x) (funcall s2 x))
;;                  (progn 
;;                    (setf state 1)
;;                    t) 
;;                  nil)
;;           (progn 
;;             (if (< (funcall s1 x) (funcall s2 x))
;;                 (setf state 0))
;;             nil)))))

;; (defun cross-from-above (s1 s2)
;;   (let ((state 0))
;;     (lambda (x)
;;       (if (= state 0)
;;           (if (< (funcall s1 x) (funcall s2 x))
;;                  (progn 
;;                    (setf state 1)
;;                    t) 
;;                  nil)
;;           (progn 
;;             (if (> (funcall s1 x) (funcall s2 x))
;;                 (setf state 0))
;;             nil)))))


(defun ema-price-cross (init alpha) 
  (let ((ind (ema alpha))) 
    (wait-as init
             (cross-from-below (price) ind) 
             (wait-as (bullish) 
                      (cross-from-above (price) ind)
                      (ema-price-cross (bearish) alpha)))))

(defun cross (fast slow bullish bearish)
  (let ((state 'neutral))
    (lambda (x)
      (format t " state: ~a" state)
      (prog1 (case state
               ('neutral (funcall (neutral) x))
               ('bullish (funcall bullish x))
               ('bearish (funcall bearish x)))
        (if (or (eq state 'neutral) (eq state 'bearish))
            (if (funcall (cross-from-below fast slow) x) 
                (setf state 'bullish))
            (if (funcall (cross-from-above fast slow) x) 
                (setf state 'bearish)))))))

;; (defun cross (fast slow)
;;   (labels ((cross-from (init fast slow)
;;              (wait-as init
;;                       (cross-from-below fast slow) 
;;                       (wait-as (bullish) 
;;                                (cross-from-above fast slow)
;;                                (cross-from (bearish) fast slow)))))
;;     (cross-from (neutral) fast slow)))
;; (cross (price) (ema 0.1))

;; (defun wait-as (before event after)
;;   (if event
;;       (pandoric-hotpatch before after))
;;   )


(defun counter (increment)
  (pandoriclet ((state 0))
    (lambda ()
      (incf state increment)
      state)))

(let ((c (counter 1)))
  (print (funcall c))
  (print (funcall c)))

;; (defun main ()
;;   (declare (optimize (speed 3)
;;                      (safety 0)
;;                      (debug 0)))
;;   (let* ((size 10000000)
;;          (x (make-array size :element-type 'double-float 
;;                         :initial-element 1d0))
;;          (indicator (ema 0.1d0)))
;;     (time (dotimes (i size)
;;             (declare (type fixnum i))
;;             (let ((y (funcall indicator (aref x i))))
;;               (declare (ignorable y))
;;               ;; (format t "~a ~a~%" (aref x i) y)
;;               )))))



;; (defun main2 ()
;;   (declare (optimize (speed 3)
;;                      (safety 0)
;;                      (debug 0)))
;;   (let* ((size 100)
;;          (x (make-array size :element-type 'double-float 
;;                         :initial-contents (loop for i from 0 to (- size 1) collect (sin (* (/ (* 2.0 pi) size) i)))))
;;          ;; (strategy (cross (price) (ema 0.1d0)))
;;          (ind (ema 0.1d0)))
;;     (labels ((strategy ()
;;                (wait-as (neutral) (cross-from-below (price) ind) (delay (wait-as (bullish) (cross-from-above (price) ind) (delay (strategy)))))))
;;       (let ((s (strategy)))
;;         (time (dotimes (i size)
;;                 (declare (type fixnum i))
;;                 (format t "~a: x=~a " i (aref x i))
;;                 (let ((p (funcall s (aref x i))))
;;                   (declare (ignorable p))
;;                   (format t "p=~a~%" p))))))))


(defun main2 ()
  (declare (optimize (speed 3)
                     (safety 0)
                     (debug 0)))
  (let* ((size 101)
         (x (make-array (+ size 1) :element-type 'double-float 
                        :initial-contents (loop for i from 0 to size collect (sin (* (/ (* 2.0 pi) (- size 1)) i)))))
         ;; (strategy (cross (price) (ema 0.1d0)))
         (ind1 (ema 0.1d0))
         (ind2 (ema 0.5d0)))
    (let ((s (cross (price) ind1 (cross (price) ind2 (bullish) (neutral)) (cross (price) ind2 (neutral) (bearish)))))
      (time (dotimes (i size)
              (declare (type fixnum i))
              (format t "~a: x=~a " i (aref x i))
              (let ((p (funcall s (aref x i))))
                (declare (ignorable p))
                (format t " p=~a~%" p)))))))
(main2)
