(in-package :6040)

(defmacro delay (expr)
     `(lambda () ,expr))

(defun force (delayed-object)
  (funcall delayed-object))

(defun add (to from val)
  (let ((size (array-dimension to 0)))
    (dotimes (i size)
      (setf (aref to i) (+ (aref from i) val)))))

;; (defmacro definline (f args &body body)
;;   `(progn (declaim (inline ,f))
;;           (defun ,f ,args ,@body)))
;; (definline price ()
;;   (lambda (x)
;;     x))
(declaim (inline price))
(defun price ()
  (lambda (x)
    x))

(declaim (inline ema))
(defun ema (alpha)
  (declare (type double-float alpha))
  #f
  (let* ((1-alpha (- 1d0 alpha))
         (state 0d0))
    (declare (type double-float 1-alpha state))
    (lambda (x)
      (declare (type double-float x))
      (setf state (+ (* alpha x) (* 1-alpha state)))
      ;; (format t " ema=~a " state)
      state)))

;; (defun bullish ()
;;   (lambda (x)
;;     (declare (ignore x))
;;     1))
;; (defun bearish () 
;;   (lambda (x)
;;     (declare (ignore x))
;;     -1))
;; (defun neutral () 
;;   (lambda (x)
;;     (declare (ignore x))
;;     0))


;; (defun wait-as (before event after)
;;   (pandoriclet ((state 0))
;;     (lambda (x) 
;;       (format t " state: ~a" state)
;;       (if (= state 0)
;;           (if (funcall event x)
;;               (progn (format t " *************")
;;                      (setf state 1) 
;;                      (funcall before x))
;;               (funcall before x)) 
;;           (progn 
;;             (format t " calling after")
;;             (funcall (force after) x))))))
;; (defun wait-as (before event after)
;;   (pandoriclet ((state 0))
;;     (if event
;;         (pandoric-hotpatch before after)))
;;   )

(declaim (inline cross-from-below))
(defun cross-from-below (s1 s2)
  #f
  (declare (type function s1 s2))
  (lambda (x)
    (if (> (the double-float (funcall s1 x)) (the double-float (funcall s2 x)))
        (progn ;; (format t " cross-from-below")
          t)
        nil)))

(declaim (inline cross-from-above))
(defun cross-from-above (s1 s2)
  #f
  (declare (type function s1 s2))
  (lambda (x)
    (if (< (the double-float (funcall s1 x)) (the double-float (funcall s2 x)))
        (progn ;; (format t " cross-from-below")
          t)
        nil)))


;; (defun cross (fast slow bullish bearish)
;;   (let ((state 'neutral))
;;     (lambda (x)
;;       (format t " state: ~a" state)
;;       (prog1 (case state
;;                ('neutral (funcall (neutral) x))
;;                ('bullish (funcall bullish x))
;;                ('bearish (funcall bearish x)))
;;         (if (or (eq state 'neutral) (eq state 'bearish))
;;             (if (funcall (cross-from-below fast slow) x) 
;;                 (setf state 'bullish))
;;             (if (funcall (cross-from-above fast slow) x) 
;;                 (setf state 'bearish)))))))

;; (defun cross (fast slow)
;;   (labels ((cross-from (init fast slow)
;;              (wait-as init
;;                       (cross-from-below fast slow) 
;;                       (wait-as (bullish) 
;;                                (cross-from-above fast slow)
;;                                (cross-from (bearish) fast slow)))))
;;     (cross-from (neutral) fast slow)))
;; (cross (price) (ema 0.1))

;; (defun counter (increment)
;;   (pandoriclet ((state 0))
;;     (lambda ()
;;       (incf state increment)
;;       state)))

;; (let ((c (counter 1)))
;;   (print (funcall c))
;;   (print (funcall c)))

;; (defun main ()
;;   (declare (optimize (speed 3)
;;                      (safety 0)
;;                      (debug 0)))
;;   (let* ((size 10000000)
;;          (x (make-array size :element-type 'double-float 
;;                         :initial-element 1d0))
;;          (indicator (ema 0.1d0)))
;;     (time (dotimes (i size)
;;             (declare (type fixnum i))
;;             (let ((y (funcall indicator (aref x i))))
;;               (declare (ignorable y))
;;               ;; (format t "~a ~a~%" (aref x i) y)
;;               )))))



;; (defun main2 ()
;;   (declare (optimize (speed 3)
;;                      (safety 0)
;;                      (debug 0)))
;;   (let* ((size 100)
;;          (x (make-array size :element-type 'double-float 
;;                         :initial-contents (loop for i from 0 to (- size 1) collect (sin (* (/ (* 2.0 pi) size) i)))))
;;          ;; (strategy (cross (price) (ema 0.1d0)))
;;          (ind (ema 0.1d0)))
;;     (labels ((strategy ()
;;                (wait-as (neutral) (cross-from-below (price) ind) (delay (wait-as (bullish) (cross-from-above (price) ind) (delay (strategy)))))))
;;       (let ((s (strategy)))
;;         (time (dotimes (i size)
;;                 (declare (type fixnum i))
;;                 (format t "~a: x=~a " i (aref x i))
;;                 (let ((p (funcall s (aref x i))))
;;                   (declare (ignorable p))
;;                   (format t "p=~a~%" p))))))))

(declaim (inline bullish))
(defun bullish ()
  #f 
  (lambda (x) (declare (ignore x)) 1)
;; (labels ((state (x) (declare (ignore x)) 1))
  ;;   (lambda (x)
  ;;     (state x)))
  )

(declaim (inline bearish))
(defun bearish ()
  #f
  (lambda (x) (declare (ignore x)) -1)
  ;; (labels ((state (x) (declare (ignore x)) -1))
  ;;   (lambda (x)
  ;;     (state x)))
  )
(declaim (inline neutral))
(defun neutral ()
  #f
  (lambda (x) (declare (ignore x)) 0)
  ;; (labels ((state (x) (declare (ignore x)) 0))
  ;;   (lambda (x)
  ;;     (state x)))
  )

(declaim (inline cross))
(defun cross (fast slow bullish bearish)
  #f
  (let ((state (neutral)))
    (declare (type function state fast slow)
                                        ;(ftype (function (double-float) fixnum) state)
             )
    (lambda (x)
      ;; (my-debug "cross" nil state)
      (prog1 (funcall state x)
        (if (>= (the double-float (funcall fast x)) (the double-float (funcall slow x)))
            (setf state bullish)
            (setf state bearish))))))

(defun wait-as (before event after)
  (let ((state before))
    (lambda (x)
      (my-debug "wait-as" nil state)
      (prog1 (funcall state x)
        (if (funcall event x)
            (setf state (force after)))))))

;; (defun cross2 (fast slow bullish bearish)
;;   (labels ((cross-from (init)
;;              (wait-as init
;;                           (cross-from-below fast slow) 
;;                           (delay (wait-as bullish 
;;                                     (cross-from-above fast slow) 
;;                                     (delay (cross-from bearish)))))))
;;     (cross-from (neutral))))

;; (defun cross3 (fast slow bullish bearish)
;;   (labels ((cross-from (init fast slow target)
;;              (wait-as init
;;                           (cross-from-below fast slow) 
;;                           (delay (cross-from target slow fast bearish)))))
;;     (cross-from (neutral) fast slow bullish)))


(defun main2 ()
  #f
  (let* ((size 10000001)
         (cycles 2)
         ;; (x (make-array (+ size 1) :element-type 'double-float 
         ;;                :initial-contents (loop for i from 0 to size collect (sin (* (/ (* 2.0 pi cycles) (- size 1)) i)))))
         ;; (strategy (cross (price) (ema 0.1d0)))
         ;; (ind1 (ema 0.1d0))
         ;; (ind2 (ema 0.5d0))
         )
    (let ( ;; (s0 (cross (price) ind1 (bullish) (bearish)))
          ;; (s (cross (price) ind1 (cross (price) ind2 (bullish) (neutral)) (cross (price) ind2 (neutral) (bearish))))
          (s (cross (price) (ema 0.1d0) (bullish) (bearish))))
      (time (dotimes (i size)
              (declare (type fixnum i))
              ;; (format t "~a: x=~a " i (aref x i))
              (let* ((x (sin (* (/ (* 2.0 pi cycles) (- size 1)) i)))
                     (p (funcall s x)))
                (declare (ignorable p))
                ;; (format t " p=~a~%" p)
                )))
      ;; (my-debug "main" s)
      )))

;; (main2)




